#+TITLE: AI XPrize Architecture
#+AUTHOR:

#+REVEAL_TRANS: linear
#+REVEAL_THEME: night

* Core Requirements
- Interfaces with ROS-Indigo.
- Easy to slot new components in and out.
- Able to add new components using different languages.
* The Robotic Operating System (ROS)
- Protocol that allows easy interface between different =rosnode='s to
  send messages back and forth.
- Allows communication across languages.
- =rosjava= is the Java interface to ROS.
* The Unstructured Information Management Architecture (UIMA)
- Pipeline architecture used for information processing.
- Notably used (and significantly improved) in the IBM Watson
  project.
- Primarily written in Java.
  + Support for other languages, such as C++ exist, but appear to be
    deprecated.
** Common Analysis System (CAS)
- "Universal" datatype used by all components of UIMA.
- Holds some base information with various annotations written on top
  of it.
** Annotators
- Central component in UIMA.
- Inputs a CAS object, and adds new annotation objects to it.
- Defined by XML Descriptor file.
- Classes representing annotation types are auto-generated by UIMA.
#+BEGIN_SRC java
  public class MyAnnotator {
      @Override
      public void process(JCas cas) throws AnalysisEngineProcessException {
          String docText = cas.getDocumentText();
          int location;
          if ((location = docText.indexOf("purple")) != -1) {
              Color color = new Color(cas);
              color.setBegin(location);
              color.setEnd(location + "purple".length());
              color.setColorName("purple");
              color.addToIndexes(cas);
          }
      }
  }
#+END_SRC
** Aggregate Analysis Engines
- Allows for chaining multiple annotators together.
- Essentially just an XML Descriptor file that orders other XML
  Descriptors.
* Universal UIMA
- Our design for making UIMA multi-lingual.
- Currently implemented using HTTP.
- Could be feasible over different protocols in the future.
** HTTP UIMA Protocol
- Serialize CAS object into JSON using built-in UIMA functions.
- Send Multipart HTTP request to an external server with the JSON-CAS
  and any necessary binary data.
- External annotator (acting as a server) receives the request,
  processes it, and returns a list of annotations in JSON like so:
#+BEGIN_SRC javascript
  {
      "my_string_annotation": [
          {
              "begin": 0,
              "end": 3,
              "my_string_field": "bar"
          },
          {
              "begin": 5,
              "end": 10,
              "my_string_field": "foo"
          }
      ],
      "my_int_annotation": [
          {
              "my_int_field": 5,
              "my_other_string_field": "foobar"
          }
      ]
  }
#+END_SRC
** Using the Protocol
- Goal to necessitate as little Java code as possible when writing an
  external annotator.
#+BEGIN_SRC java :export source
  public class ColorsAnnotator extends HttpAnnotator {
      @Override
      protected Class<? extends Annotation> getAnnotationClass(String name)
              throws NoMatchingAnnotationException {
          if (name.equals("Color"))
              return Color.class;
          throw new HttpAnnotator.NoMatchingAnnotationException();
      }
  }
#+END_SRC
- If the annotation type only uses primitives, no additional code is
  necessary; the annotations auto-magically appear on the CAS.
- Otherwise, the subclass needs only to override a single method to
  add custom behavior.
#+BEGIN_NOTES
Should probably mention that we don't use a =RuntimeException= to
emphasize that this /must/ be handled in the superclass.
#+END_NOTES
** Configuration
- External annotators will have their access defined in a global JSON
  file, either distributed ahead of time or on some server at a fixed
  location.
#+BEGIN_SRC javascript
  {
      "annotator_name": {
          "address": "123.45.67.89",
          "port": 1234
      },
      "other_annotator_name": {
          "address": "123.45.67.80",
          "port": 4321
      }
  }
#+END_SRC
* Resulting Architecture Diagram
#+BEGIN_SRC plantuml :file architecture.png
  node Microphone {
      [MicrophoneBroadcaster]
  }

  node Arm {
      [ArmListener]
  }

  folder Descriptors {
      [MainAEDescriptor] --> [InputAEDescriptor]
      [MainAEDescriptor] --> [ProcessingAEDescriptor]
      [MainAEDescriptor] --> [OutputAEDescriptor]

      [InputAEDescriptor] --> [MicrophoneInputReaderDescriptor]

      [ProcessingAEDescriptor] --> [SpeechToTextDescriptor]
      [ProcessingAEDescriptor] --> [TextToColorsDescriptor]

      [OutputAEDescriptor] --> [ArmOutputDescriptor]
  }

  node Pipeline {
      [Controller] ..> [MainAEDescriptor]: Loads

      [MicrophoneBroadcaster] ..> [MicrophoneInputReader]: ROSMSG

      [SpeechToTextAnnotator_Stub]
      [TextToColorsAnnotator]

      [ArmOutput] ..> [ArmListener]: ROSMSG
  }

  cloud External {
      [SpeechToTextAnnotator_Stub] .. [SpeechToTextAnnotator]: HTTP
  }
#+END_SRC

#+RESULTS:
[[file:architecture.png]]
* Demo
* Questions?
