* Rose-Hulman AI XPrize Data Pipeline
** Introduction
IBM is holding an AI XPrize competition that our school, Rose-Hulman
Institute of Technology, is participating in. Details on the
competition are found here: http://ai.xprize.org, and information
about the vision for the finished product can be found here:
https://wordpress.rose-hulman.edu/ai-group/.

This project is intended to allow for the usage of different AI
components across different languages and possibly even machines all
linked together using [[uima.apache.org][UIMA]], the Unstructured Information Management
Architecture.

The program communicates with the robot using [[ros.org][ROS]], the robotic
operating system, and will be in charge of processing the data sent to
it by the robot's sensors and sending abstract commands for the robot
to execute.
** Dependencies
- Java 1.8
- ROS Indigo
- UIMA
- Gradle
- ROSJava
** Installation
This repository is a ROS package, and as such should be cloned into
your =catkin_ws/src= folder (see [[http://wiki.ros.org/catkin/Tutorials/create_a_workspace][this tutorial]] for information about
setting up a workspace).

#+BEGIN_SRC bash
  cd catkin_ws/src
  git clone https://github.com/RHIT-XPrize/rhit-xprize-pipeline edu_rosehulman_aixprize

  cd ..
  catkin_make

  source catkin_ws/devel/setup.bash
#+END_SRC

Note that projects will be Gradle projects, and should be imported as
such.
** Usage
#+BEGIN_SRC bash
  roscore &
  rosrun edu_rosehulman_aixprize pipeline edu.rosehulman.aixprize.pipeline.core.Controller
#+END_SRC

The =rosrun= will ask you to select which binary to use. Select one
under the =bin/= folder.
** Troubleshooting
- ROS is unable to find the package
  + Ensure that you cloned the repository into a folder named
    =edu_rosehulman_aixprize=.
  + Make sure you've run =source catkin_ws/setup.bash= during this
    terminal session. (Better yet, add it to your =~/.bashrc=
** Communication Protocol
Java annotators will act as clients to the external annotators, which
will act as servers, the two of which will communicate over HTTP.

Most data will be sent in JSON format. These JSON blobs will be
un-prettified and written on a /single line/. The examples below are
prettified, and as such /are not valid/, however for readability we've
formatted them as such.
*** Setup
Each annotator pair will use a set address and port number read in
from a JSON configuration file formatted as a list of objects in this
form:
#+BEGIN_SRC javascript
  {
      "annotator_name": {
          "address": "123.45.67.89",
          "port": 1234
      },
      "other_annotator_name": {
          "address": "123.45.67.80",
          "port": 4321
      }
  }
#+END_SRC
*** Configuration
After the servers are set up, the Java annotators will send a request
with the configuration details pulled from the =UimaContext= object,
again in JSON. The names of the annotations and annotation field keys
that will be used are also sent to the server at this point.
*** Communication
Standard communications will use a multipart =POST= request. The body
of this request will be a sequence of pertinent pieces of data, such
as binary blobs of audio or video along with the JSON-ified CAS
object. The various pieces of data must be agreed upon by both the
sender and receiver, but the CAS will /always/ be transmitted.

The server will then respond with an HTTP Response which, if
successful, includes a JSON object with a list of annotations by type,
where each of the fields of the goal annotation are specified as the
body of the response:
#+BEGIN_SRC javascript
  {
      "my_string_annotation": [
          {
              "begin": 0,
              "end": 3,
              "my_string_field": "bar"
          },
          {
              "begin": 5,
              "end": 10,
              "my_string_field": "foo"
          }
      ],
      "my_int_annotation": [
          {
              "begin": 12,
              "end": 13,
              "my_int_field": 5,
              "my_other_string_field": "foobar"
          }
      ]
  }
#+END_SRC
